// Copyright 2018-2019 Espressif Systems (Shanghai) PTE LTD
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "driver/spi_master.h"
#include "soc/gpio_struct.h"
#include "driver/gpio.h"
#include "driver/uart.h"
#include "soc/uart_struct.h"
#include <math.h>

#include "esp_dsp.h"

//tflite related
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/schema/schema_generated.h"
#include "tensorflow/lite/micro/tflite_bridge/micro_error_reporter.h"
//helper headers with weights for each functions
#include "mel_filterbank.h" //generated from generate_melbank.py
#include "model_data.h" //generated by xxd

extern "C" {
    void app_main(void);
}

static const char *TAG = "main";
//VARIABLES for melspectrogram
#define SAMPLING_RATE 16000
#define N_FFT 512
#define WIN_LENGTH 480
#define HOP_LENGTH 320

extern float fft_output[N_FFT * 2];

// This example shows how to use FFT from esp-dsp library
// Input array for melspectrograms
__attribute__((aligned(16)))
float audio_input[WIN_LENGTH];
// Window coefficients
__attribute__((aligned(16)))
float wind[WIN_LENGTH];
// working complex array
__attribute__((aligned(16)))
float y_cf[N_FFT * 2];

const tflite::Model * model = nullptr;
tflite::MicroInterpreter * interpreter = nullptr;
TfLiteTensor * model_input = nullptr;
TfLiteTensor * model_output = nullptr;

constexpr int kTensorArenaSize = 180*1024;
uint8_t* tensor_arena = nullptr;

void app_main()
{
    esp_err_t ret;
    ESP_LOGI(TAG, "Start Example.");
    
    //SPECTROGRAM SETTINGS
    ret = dsps_fft2r_init_fc32(NULL, CONFIG_DSP_MAX_FFT_SIZE);
    if (ret  != ESP_OK) {
        ESP_LOGE(TAG, "Not possible to initialize FFT. Error = %i", ret);
        return;
    }

    // Generate hann window
    dsps_wind_hann_f32(wind, WIN_LENGTH);

    dsps_tone_gen_f32(audio_input, WIN_LENGTH, 1.0, 0.16, 0);

    //------------------Melspecgram code---------------------
    // Convert two input vectors to one complex vector
    for (int i = 0 ; i < WIN_LENGTH ; i++) {
        y_cf[i * 2 + 0] = audio_input[i] * wind[i];
        y_cf[i * 2 + 1] = 0;
    }
    //zero-padding
    for (int i = 0; i < N_FFT; i++){
        y_cf[i * 2 + 0] = 0;
        y_cf[i * 2 + 1] = 0;
    }

    dsps_fft2r_fc32(y_cf, N_FFT);
    dsps_bit_rev_fc32(y_cf, N_FFT);
    
    float power_spectrum[N_FFT_BINS];

    for (int i = 0; i < N_FFT_BINS; i++){
        float real = y_cf[i * 2 + 0];
        float imag = y_cf[i * 2 + 1];
        power_spectrum[i] = (real * real) + (imag * imag);
    }   

    float mel_bins[N_MELS];

    dspm_mult_f32(mel_filterbank, power_spectrum, mel_bins, N_MELS, N_FFT_BINS, 1);

    for (int i = 0; i < N_MELS; i++) {
        mel_bins[i] = 10 * log10f(mel_bins[i] + 1e-6);
    }

    ESP_LOGW(TAG, "--- Mel Spectrogram Bins (%d) ---", N_MELS);
    dsps_view(mel_bins, N_MELS, 60, 10,  -80, 40, '|'); 

    tflite::MicroErrorReporter micro_error_reporter;
    tflite::ErrorReporter * error_reporter = &micro_error_reporter;

    tensor_arena = (uint8_t*) heap_caps_malloc(kTensorArenaSize, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (tensor_arena == nullptr) {
        ESP_LOGE(TAG, "Failed to allocate tensor_arena of size %d", kTensorArenaSize);
        return; // Stop here if we're out of memory
    }
    ESP_LOGI(TAG, "Tensor Arena successfully allocated on heap.");

    model = tflite::GetModel(model_full_int8_tflite);
    if(model->version() != TFLITE_SCHEMA_VERSION) {
        ESP_LOGE(TAG, "Model Schema version %d does not match with SCHEMA VERSION %d",
            model->version(), TFLITE_SCHEMA_VERSION);
        return;
    }
    ESP_LOGI(TAG, "Model Loaded.");

    tflite::MicroMutableOpResolver<15> op_resolver;
    //add the layers usesd
    op_resolver.AddDepthwiseConv2D();
    op_resolver.AddConv2D();
    op_resolver.AddRelu();
    op_resolver.AddMaxPool2D();
    op_resolver.AddTranspose();

    op_resolver.AddFullyConnected();
    op_resolver.AddReshape();
    //InstanceNorm2d
    op_resolver.AddMean();
    op_resolver.AddSub();
    op_resolver.AddMul();
    
    op_resolver.AddDiv();
    op_resolver.AddRsqrt();
    op_resolver.AddAdd();
    op_resolver.AddSum();
    //Should Include this?
    op_resolver.AddSoftmax();

    static tflite::MicroInterpreter static_interpreter(
        model, op_resolver, tensor_arena, kTensorArenaSize);

    interpreter = &static_interpreter;

    TfLiteStatus allocate_status = interpreter->AllocateTensors();
    if(allocate_status != kTfLiteOk) {
        error_reporter->Report("AllocateTensors() failed");
        return;
    }
    ESP_LOGI(TAG, "Tensors allocated");

    model_input = interpreter->input(0);
    model_output = interpreter->output(0);

    ESP_LOGI(TAG, "Model Input Info:");
    ESP_LOGI(TAG, "Dims: %d", model_input->dims->size);
    for(int i = 0; i < model_input->dims->size; i++){
        ESP_LOGI(TAG, "Dim %d: %d", i, model_input->dims->data[i]);
    }
    ESP_LOGI(TAG, "Type: %d (3=int8, 0=float32)", model_input->type);

    for (int i = 0; i < N_MELS; i++) {
        model_input->data.f[i] = mel_bins[i];
    }
    ESP_LOGI(TAG, "Input data copied to tensor.");

    TfLiteStatus invoke_status = interpreter->Invoke();
    if(invoke_status != kTfLiteOk){
        error_reporter->Report(TAG, "Invoke() failed");
        return;
    }
    ESP_LOGI(TAG, "Model invoked successfully");

    ESP_LOGI(TAG, "Model Output Info: ");
    ESP_LOGI(TAG, "Dims %d", model_output->dims->size);
    int output_dims_count = model_output->dims->data[model_output->dims->size - 1];
    ESP_LOGI(TAG, "Last Dim (classes): %d", output_dims_count);
    ESP_LOGI(TAG, "Type: %d (3=int8, 0=float32)", model_output->type);

    ESP_LOGW(TAG, "---Model Output---");
    for(int i = 0; i < output_dims_count; i++){
        float score = model_output->data.f[i];
        ESP_LOGI(TAG, "Class %d: %f", i, score);
    }

    ESP_LOGI(TAG, "End Example.");
}
